<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled :: Apache Camel</title>
    <link rel="canonical" href="https://camel.apache.org/manual/latest/oncompletion.html">
    <meta name="generator" content="Antora 2.0.0-rc.1">
    <link rel="stylesheet" href="../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://camel.apache.org">Apache Camel</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Resource A</a>
            <a class="navbar-item" href="#">Resource B</a>
            <a class="navbar-item" href="#">Resource C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="main-wrapper">
<div class="navigation-container" data-component="manual" data-version="latest">
  <aside class="navigation">
    <div class="panels">
<div class="navigation-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">User manual</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <a class="nav-link" href="getting-started.html">Getting started</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="book-getting-started.html">Getting Started with Apache Camel</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <a class="nav-link" href="architecture.html">Architecture</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="async.html">Async</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="asynchronous-routing-engine.html">Asynchronous Routing Engine</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="backlogdebugger.html">Backlog debugger</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="bam.html">Business Activity Monitoring</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="batch-consumer.html">Batch Consumer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="browsable-endpoint.html">BrowsableEndpoint</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="camel-core.html">Core</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="camelcontext.html">Context</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="endpoint.html">Endpoints</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="cep.html">Complex Event Processing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="component.html">Component</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="debugger.html">Debugger</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="delay-interceptor.html">Delay interceptor</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="dependency-injection.html">Dependency Injection</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="dozer-type-conversion.html">Dozer Type Conversion</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="bean-integration.html">Bean Integration</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="error-handler.html">Error Handler</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="exchange.html">Message Exchange</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="exchange-pattern.html">Exchange Pattern</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="expression.html">Expressions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="injector.html">Injector</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="intercept.html">Intercept</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="inversion-of-control-with-smart-defaults.html">Inversion Of Control With Smart Defaults</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="lifecycle.html">Camel Lifecycle</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="oncompletion.html">OnCompletion</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="predicate.html">Predicates</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="registry.html">Registry</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="route-builder.html">RouteBuilder</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="routes.html">Routes</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-toggle"></button>
    <span class="nav-text">Domain Specific Languages</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="dsl.html">Camel Domain Specific Language</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="java-dsl.html">Java DSL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="spring.html">Spring support</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="groovy-dsl.html">Groovy DSL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-toggle"></button>
    <span class="nav-text">Scala DSL</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="scala-dsl.html">About the Scala DSL</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="scala-dsl-getting-started.html">Getting Started</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="scala-dsl-eip.html">EIP</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="scala-dsl-supported-languages.html">Supported languages</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="using-osgi-blueprint-with-camel.html">Using OSGi blueprint with Camel</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="navigation-explore" data-panel="explore">
  <div class="context">
    <span class="title">User manual</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component">
      <span class="title">Apache Camel K</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../camel-k/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Component reference</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../components/2.24.0-SNAPSHOT/index.html">2.24.0-SNAPSHOT</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <span class="title">User manual</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
  <main class="main">
<div class="toolbar" role="navigation">
  <button class="navigation-toggle"></button>
  <a href="index.html" class="home-link"></a>
<nav class="crumbs" aria-label="breadcrumbs">
  <ul>
    <li class="crumb"><a href="index.html">User manual</a></li>
    <li class="crumb"><a href="architecture.html">Architecture</a></li>
    <li class="crumb"><a href="oncompletion.html">OnCompletion</a></li>
  </ul>
</nav>
</div>
<article class="doc">
<div class="sect2">
<h3 id="OnCompletion-OnCompletion"><a class="anchor" href="#OnCompletion-OnCompletion"></a>OnCompletion</h3>
<div class="paragraph">
<p>Camel has this concept of a Unit of Work that encompass the
Exchange. The unit of work among others supports
synchronization callbacks that are invoked when the
Exchange is complete. The callback API is defined in
<code>org.apache.camel.spi.Synchronization</code>. From <strong>Camel 2.14</strong> onwards we
have an extended synchronization
<code>org.apache.camel.spi.SynchronizationRouteAware</code> that have callbacks for
route events.</p>
</div>
<div class="paragraph">
<p><strong>Getting the UnitOfWork</strong></p>
</div>
<div class="paragraph">
<p>You can get hold of the <code>org.apache.camel.spi.UnitOfWork</code> from
<code>org.apache.camel.Exchange</code> with the method <code>getUnitOfWork()</code>.</p>
</div>
<div class="paragraph">
<p>In Camel 2.0 we have added DSL for these callbacks using the new
<strong>onCompletion</strong> DSL name.</p>
</div>
<div class="paragraph">
<p><strong>onCompletion</strong> supports the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>scope: global and/or per route (route scope override all global scope)</p>
</li>
<li>
<p>multiple global scope</p>
</li>
<li>
<p>triggered either always, only if completed with success, or only if
failed</p>
</li>
<li>
<p><code>onWhen</code> predicate to only trigger in certain situations</p>
</li>
<li>
<p><strong>Camel 2.14:</strong> mode: to define whether to run either before or after
route consumer writes response back to callee (if its InOut)</p>
</li>
<li>
<p>*Camel 2.14:*whether to run async or sync (use a thread pool or not)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>From <strong>Camel 2.14</strong> onwards the onCompletion has been modified to support
running the completion task in either synchronous or asynchronous mode
(using a thread pool) and also whether to run before or after the route
consumer is done. The reason is to give more flexibility. For example to
specify to run synchronous and before the route consumer is done, which
allows to modify the exchange before the consumer writes back any
response to the callee. You can use this to for example add customer
headers, or send to a log to log the response message, etc.</p>
</div>
<div class="paragraph">
<p><strong>Changes from Camel 2.14 onwards</strong>
The onCompletion has changed defaults and behavior from Camel 2.14
onwards. It now runs
* Runs synchronously without any thread pool
In Camel 2.13 the defaults were
* Runs asynchronous using a thread pool</p>
</div>
<div class="paragraph">
<p><strong>Camel 2.13 or older - On completion runs in separate thread</strong></p>
</div>
<div class="paragraph">
<p>The <strong>onCompletion</strong> runs in a separate thread in parallel with the
original route. It is therefore not intended to influence the outcome of
the original route. The idea for on completion is to spin off a new
thread to eg send logs to a central log database, send an email, send
alterts to a monitoring system, store a copy of the result message
etc.<br>
 Therefore if you want to do some work that influence the original
route, then do <strong>not</strong> use <strong>onCompletion</strong> for that. Notice: if you use the
<code>UnitOfWork</code> API as mentioned in the top of this page, then you can
register a <code>Synchronization</code> callback on the
Exchange which is executed in the original route.
That way allows you to do some custom code when the route is completed;
this is how custom components can enlist on completion services which
they need, eg the File component does that for work
that moves/deletes the original file etc.</p>
</div>
<div class="sect3">
<h4 id="OnCompletion-onCompletionwithroutescope"><a class="anchor" href="#OnCompletion-onCompletionwithroutescope"></a>onCompletion with route scope</h4>
<div class="paragraph">
<p>The <strong>onCompletion</strong> DSL allows you to add custom routes/processors when
the original Exchange is complete. Camel spin off a
copy of the Exchange and routes it in a separate
thread, kinda like a Wire Tap. This allows the
original thread to continue while the <strong>onCompletion</strong> route is running
concurrently. We decided for this model as we did not want the
<strong>onCompletion</strong> route to interfere with the original route.</p>
</div>
<div class="paragraph">
<p><strong>Only 1 onCompletion supported by route scope</strong></p>
</div>
<div class="paragraph">
<p>You can only have 1 onCompletion in a route. Only at context scoped
level you can have multiple. And notice that when you use a route scoped
onCompletion then any context scoped are disabled for that given route.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("direct:start")
    .onCompletion()
        // this route is only invoked when the original route is complete as a kind
        // of completion callback
        .to("log:sync")
        .to("mock:sync")
    // must use end to denote the end of the onCompletion route
    .end()
    // here the original route contiues
    .process(new MyProcessor())
    .to("mock:result");</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default the <strong>onCompletion</strong> will be triggered when the
Exchange is complete and regardless if the
Exchange completed with success or with an failure
(such as an Exception was thrown). You can limit the trigger to only
occur <code>onCompleteOnly</code> or by <code>onFailureOnly</code> as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("direct:start")
    // here we qualify onCompletion to only invoke when the exchange failed (exception or FAULT body)
    .onCompletion().onFailureOnly()
        .to("log:sync")
        .to("mock:sync")
    // must use end to denote the end of the onCompletion route
    .end()
    // here the original route continues
    .process(new MyProcessor())
    .to("mock:result");</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can identify if the Exchange is an
<strong>onCompletion</strong> Exchange as Camel will add the
property <code>Exchange.ON_COMPLETION</code> with a boolean value of <code>true</code> when it
spin offs the <strong>onCompletion</strong> Exchange.</p>
</div>
<div class="sect4">
<h5 id="OnCompletion-UsingonCompletionfromSpringDSL"><a class="anchor" href="#OnCompletion-UsingonCompletionfromSpringDSL"></a>Using onCompletion from Spring DSL</h5>
<div class="paragraph">
<p>The onCompletion is defined like this with Spring DSL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;route&gt;
    &lt;from uri="direct:start"/&gt;
    &lt;!-- this onCompletion block will only be executed when the exchange is done being routed --&gt;
    &lt;!-- this callback is always triggered even if the exchange failed --&gt;
    &lt;onCompletion&gt;
        &lt;!-- so this is a kinda like an after completion callback --&gt;
        &lt;to uri="log:sync"/&gt;
        &lt;to uri="mock:sync"/&gt;
    &lt;/onCompletion&gt;
    &lt;process ref="myProcessor"/&gt;
    &lt;to uri="mock:result"/&gt;
&lt;/route&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the <code>onCompleteOnly</code> and <code>onFailureOnly</code> is defined as a boolean
attribute on the &lt;onCompletion&gt; tag so the failure example would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;route&gt;
    &lt;from uri="direct:start"/&gt;
    &lt;!-- this onCompletion block will only be executed when the exchange is done being routed --&gt;
    &lt;!-- this callback is only triggered when the exchange failed, as we have onFailure=true --&gt;
    &lt;onCompletion onFailureOnly="true"&gt;
        &lt;to uri="log:sync"/&gt;
        &lt;to uri="mock:sync"/&gt;
    &lt;/onCompletion&gt;
    &lt;process ref="myProcessor"/&gt;
    &lt;to uri="mock:result"/&gt;
&lt;/route&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="OnCompletion-onCompletionwithglobalscope"><a class="anchor" href="#OnCompletion-onCompletionwithglobalscope"></a>onCompletion with global scope</h4>
<div class="paragraph">
<p>This works just like the route scope except from the fact that they are
defined globally. An example below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// define a global on completion that is invoked when the exchange is complete
onCompletion().to("log:global").to("mock:sync");

from("direct:start")
    .process(new MyProcessor())
    .to("mock:result");</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="OnCompletion-UsingonCompletionfromSpringDSL.1"><a class="anchor" href="#OnCompletion-UsingonCompletionfromSpringDSL.1"></a>Using onCompletion from Spring DSL</h5>
<div class="paragraph">
<p>This works just like the route scope except from the fact that they are
defined globally. An example below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- this is a global onCompletion route that is invoke when any exchange is complete
     as a kind of after callback --&gt;
&lt;onCompletion&gt;
    &lt;to uri="log:global"/&gt;
    &lt;to uri="mock:sync"/&gt;
&lt;/onCompletion&gt;

&lt;route&gt;
    &lt;from uri="direct:start"/&gt;
    &lt;process ref="myProcessor"/&gt;
    &lt;to uri="mock:result"/&gt;
&lt;/route&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Route scope override Global scope</strong>
If an <strong>onCompletion</strong> is defined in a route, it overrides <strong>all</strong> global
scoped and thus its only the route scoped that are used. The globally
scoped ones are never used.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="OnCompletion-UsingonCompletionwithonWhenpredicate"><a class="anchor" href="#OnCompletion-UsingonCompletionwithonWhenpredicate"></a>Using onCompletion with onWhen predicate</h4>
<div class="paragraph">
<p>As other DSL in Camel you can attach a Predicate to
the <strong>onCompletion</strong> so it only triggers in certain conditions, when the
predicate matches. For example to only trigger if the message body contains the word
<code>Hello</code> we can do like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("direct:start")
    .onCompletion().onWhen(body().contains("Hello"))
        // this route is only invoked when the original route is complete as a kind
        // of completion callback. And also only if the onWhen predicate is true
        .to("log:sync")
        .to("mock:sync")
    // must use end to denote the end of the onCompletion route
    .end()
    // here the original route contiues
    .to("log:original")
    .to("mock:result");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="OnCompletion-UsingonCompletionwithorwithoutthreadpool"><a class="anchor" href="#OnCompletion-UsingonCompletionwithorwithoutthreadpool"></a>Using onCompletion with or without thread pool</h4>
<div class="paragraph">
<p><strong>Available as of Camel 2.14</strong></p>
</div>
<div class="paragraph">
<p>OnCompletion will from Camel 2.14 onwards not use thread pool by
default. To use thread pool then either set a <code>executorService</code> or set
<code>parallelProcessing</code> to true.</p>
</div>
<div class="paragraph">
<p>For example in Java DSL do</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">                onCompletion().parallelProcessing()
                    .to("mock:before")
                    .delay(1000)
                    .setBody(simple("OnComplete:${body}"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>And in XML DSL</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">      &lt;onCompletion parallelProcessing="true"&gt;
        &lt;to uri="before"/&gt;
        &lt;delay&gt;&lt;constant&gt;1000&lt;/constant&gt;&lt;/delay&gt;
        &lt;setBody&gt;&lt;simple&gt;OnComplete:${body}&lt;/simple&gt;&lt;/setBody&gt;
      &lt;/onCompletion&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also refer to a specific thread pool
to be used, using the executorServiceRef option</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">      &lt;onCompletion executorServiceRef="myThreadPool"&gt;
        &lt;to uri="before"/&gt;
        &lt;delay&gt;&lt;constant&gt;1000&lt;/constant&gt;&lt;/delay&gt;
        &lt;setBody&gt;&lt;simple&gt;OnComplete:${body}&lt;/simple&gt;&lt;/setBody&gt;
      &lt;/onCompletion&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="OnCompletion-UsingonCompletiontorunbeforerouteconsumersendsbackresponsetocallee"><a class="anchor" href="#OnCompletion-UsingonCompletiontorunbeforerouteconsumersendsbackresponsetocallee"></a>Using onCompletion to run before route consumer sends back response to callee</h4>
<div class="paragraph">
<p><strong>Available as of Camel 2.14</strong></p>
</div>
<div class="paragraph">
<p>OnCompletion supports two modes</p>
</div>
<div class="ulist">
<ul>
<li>
<p>AfterConsumer - Default mode which runs after the consumer is done</p>
</li>
<li>
<p>BeforeConsumer - Runs before the consumer is done, and before the
consumer writes back response to the callee</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The AfterConsumer mode is the default mode which is the same behavior as
in older Camel releases.</p>
</div>
<div class="paragraph">
<p>The new BeforeConsumer mode is used to run onCompletion before the
consumer writes its response back to the callee (if in InOut mode). This
allows the onCompletion to modify the Exchange, such as adding special
headers, or to log the Exchange as a response logger etc.</p>
</div>
<div class="paragraph">
<p>For example to always add a "created by" header you
use <code>modeBeforeConsumer()</code> as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    .onCompletion().modeBeforeConsumer()
        .setHeader("createdBy", constant("Someone"))
    .end()</code></pre>
</div>
</div>
<div class="paragraph">
<p>And in XML DSL you set the mode attribute to BeforeConsumer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">      &lt;onCompletion mode="BeforeConsumer"&gt;
        &lt;setHeader headerName="createdBy"&gt;
          &lt;constant&gt;Someone&lt;/constant&gt;
        &lt;/setHeader&gt;
      &lt;/onCompletion&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="OnCompletion-SeeAlso"><a class="anchor" href="#OnCompletion-SeeAlso"></a>See Also</h4>
<div class="ulist">
<ul>
<li>
<p>Unit of Work</p>
</li>
</ul>
</div>
</div>
</div>
</article>
  </main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../_/js/site.js"></script>
<script src="../../_/js/vendor/highlight.js"></script>
<script>hljs.initHighlighting()</script>
  </body>
</html>
